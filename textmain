#include <SFML/Graphics.hpp>
//#include <SFML/Window.hpp>
//#include <SFML/System.hpp>
#include <vector>
#include <string>
#include <sstream>
#include <cmath>
#include <iostream>
#include <algorithm> // for std::min / std::max


enum GameState {
    MENU,
    PLAYING,
    PAUSED,
    LEVEL_COMPLETE,
    GAME_OVER
};

struct Platform {
    sf::RectangleShape shape;
    bool breakable;
    float breakTimer;

    Platform(float x, float y, float w, float h, sf::Color color, bool canBreak = false)
        : breakable(canBreak), breakTimer(0) {
        shape.setPosition(x, y);
        shape.setSize(sf::Vector2f(w, h));
        shape.setFillColor(color);
        shape.setOutlineThickness(2);
        shape.setOutlineColor(sf::Color(color.r - 30, color.g - 30, color.b - 30));
    }
};

struct Diamond {
    sf::ConvexShape shape;
    bool collected;
    float animOffset;

    Diamond(float x, float y) : collected(false), animOffset(0) {
        shape.setPointCount(4);
        shape.setPoint(0, sf::Vector2f(10, 0));
        shape.setPoint(1, sf::Vector2f(20, 10));
        shape.setPoint(2, sf::Vector2f(10, 20));
        shape.setPoint(3, sf::Vector2f(0, 10));
        shape.setPosition(x, y);
        shape.setFillColor(sf::Color::Cyan);
        shape.setOutlineThickness(2);
        shape.setOutlineColor(sf::Color(0, 200, 200));
    }

    void update() {
        animOffset += 0.05f;
        float yOffset = sin(animOffset) * 5;
        sf::Vector2f basePos = shape.getPosition();
        shape.setPosition(basePos.x, basePos.y + yOffset - sin(animOffset - 0.05f) * 5);
    }

    sf::FloatRect getBounds() const {
        return shape.getGlobalBounds();
    }
};

struct Enemy {
    sf::CircleShape body;
    sf::CircleShape eye1;
    sf::CircleShape eye2;
    sf::RectangleShape fin1;
    sf::RectangleShape fin2;
    sf::Vector2f position;
    float speed;
    int direction;
    float minX, maxX;
    float animOffset;
    std::string type;

    Enemy(float x, float y, float spd, float min, float max, std::string enemyType = "fish")
        : position(x, y), speed(spd), direction(1), minX(min), maxX(max),
        animOffset(0), type(enemyType) {

        if (type == "jellyfish") {
            body.setRadius(20);
            body.setFillColor(sf::Color(255, 100, 180, 200));
            body.setPointCount(8);
        }
        else if (type == "crab") {
            body.setRadius(15);
            body.setFillColor(sf::Color(220, 50, 50));
        }
        else {
            body.setRadius(15);
            body.setFillColor(sf::Color(50, 120, 200));
        }

        eye1.setRadius(3);
        eye1.setFillColor(sf::Color::White);
        eye2.setRadius(3);
        eye2.setFillColor(sf::Color::White);

        fin1.setSize(sf::Vector2f(10, 5));
        fin1.setFillColor(sf::Color(30, 90, 170));
        fin2.setSize(sf::Vector2f(10, 5));
        fin2.setFillColor(sf::Color(30, 90, 170));

        updatePosition();
    }

    void updatePosition() {
        body.setPosition(position);
        eye1.setPosition(position.x + 8, position.y + 8);
        eye2.setPosition(position.x + 18, position.y + 8);

        if (direction > 0) {
            fin1.setPosition(position.x - 8, position.y + 10);
            fin2.setPosition(position.x - 8, position.y + 18);
        }
        else {
            fin1.setPosition(position.x + body.getRadius() * 2, position.y + 10);
            fin2.setPosition(position.x + body.getRadius() * 2, position.y + 18);
        }
    }

    void update() {
        position.x += direction * speed;
        if (position.x <= minX || position.x >= maxX) {
            direction *= -1;
        }

        animOffset += 0.1f;
        position.y += sin(animOffset) * 0.5f;

        updatePosition();
    }

    void draw(sf::RenderWindow& window) {
        window.draw(body);
        window.draw(fin1);
        window.draw(fin2);
        window.draw(eye1);
        window.draw(eye2);
    }

    sf::FloatRect getBounds() const {
        return body.getGlobalBounds();
    }
};

struct Hammer {
    sf::RectangleShape handle;
    sf::RectangleShape head;
    sf::Vector2f position;
    bool collected;

    Hammer(float x, float y) : position(x, y), collected(false) {
        handle.setSize(sf::Vector2f(15, 10));
        handle.setPosition(x, y + 15);
        handle.setFillColor(sf::Color(139, 69, 19));

        head.setSize(sf::Vector2f(20, 15));
        head.setPosition(x + 5, y);
        head.setFillColor(sf::Color(105, 105, 105));
    }

    sf::FloatRect getBounds() const {
        return sf::FloatRect(position.x, position.y, 25, 25);
    }

    void draw(sf::RenderWindow& window) {
        window.draw(handle);
        window.draw(head);
    }
};

struct Boulder {
    sf::RectangleShape shape;
    std::vector<sf::RectangleShape> cracks;
    bool broken;

    Boulder(float x, float y) : broken(false) {
        shape.setSize(sf::Vector2f(50, 50));
        shape.setPosition(x, y);
        shape.setFillColor(sf::Color(85, 85, 85));
        shape.setOutlineThickness(3);
        shape.setOutlineColor(sf::Color(51, 51, 51));

        for (int i = 0; i < 3; i++) {
            sf::RectangleShape crack(sf::Vector2f(30, 2));
            crack.setPosition(x + 10, y + 15 + i * 12);
            crack.setFillColor(sf::Color(40, 40, 40));
            cracks.push_back(crack);
        }
    }

    void draw(sf::RenderWindow& window) {
        window.draw(shape);
        for (auto& crack : cracks) {
            window.draw(crack);
        }
    }

    sf::FloatRect getBounds() const {
        return shape.getGlobalBounds();
    }
};

struct FallingRock {
    sf::CircleShape shape;
    sf::Vector2f position;
    sf::Vector2f velocity;
    bool active;
    bool triggered;
    float resetTimer;
    float startY;

    FallingRock(float x, float y) : position(x, y), velocity(0, 0),
        active(false), triggered(false), resetTimer(0), startY(y) {
        shape.setRadius(12);
        shape.setFillColor(sf::Color(100, 100, 100));
        shape.setOutlineThickness(2);
        shape.setOutlineColor(sf::Color(70, 70, 70));
        shape.setPosition(position);
    }

    void update(sf::FloatRect playerBounds) {
        if (!triggered && resetTimer <= 0) {
            // Only trigger if player is close AND below the rock
            if (abs(playerBounds.left - position.x) < 40 && playerBounds.top > position.y) {
                triggered = true;
                active = true;
            }
        }

        if (active) {
            velocity.y += 0.5f;
            position.y += velocity.y;
            shape.setPosition(position);

            if (position.y > 650) {
                active = false;
                triggered = false;
                resetTimer = 240; // Longer reset time
                position.y = startY;
                velocity.y = 0;
                shape.setPosition(position);
            }
        }

        if (resetTimer > 0) resetTimer--;
    }

    sf::FloatRect getBounds() const {
        return shape.getGlobalBounds();
    }
};

struct Icicle {
    sf::ConvexShape shape;
    sf::Vector2f position;
    sf::Vector2f velocity;
    bool falling;
    float fallTimer;
    float resetTimer;
    float startY;

    Icicle(float x, float y) : position(x, y), velocity(0, 0), falling(false),
        fallTimer(60), resetTimer(0), startY(y) {
        shape.setPointCount(3);
        shape.setPoint(0, sf::Vector2f(0, 0));
        shape.setPoint(1, sf::Vector2f(8, 0));
        shape.setPoint(2, sf::Vector2f(4, 30));
        shape.setPosition(position);
        shape.setFillColor(sf::Color(200, 230, 255));
        shape.setOutlineThickness(1);
        shape.setOutlineColor(sf::Color(150, 200, 255));
    }

    void update(sf::FloatRect playerBounds) {
        if (!falling && resetTimer <= 0) {
            if (abs(playerBounds.left - position.x) < 40 && playerBounds.top < position.y) {
                fallTimer--;
                if (fallTimer <= 0) {
                    falling = true;
                }
            }
            else {
                fallTimer = 60;
            }
        }

        if (falling) {
            velocity.y += 0.8f;
            position.y += velocity.y;
            shape.setPosition(position);

            if (position.y > 650) {
                falling = false;
                resetTimer = 300;
                position.y = startY;
                velocity.y = 0;
                fallTimer = 60;
                shape.setPosition(position);
            }
        }

        if (resetTimer > 0) resetTimer--;
    }

    sf::FloatRect getBounds() const {
        return shape.getGlobalBounds();
    }
};

struct LavaPool {
    sf::RectangleShape shape;
    sf::Vector2f position;
    float animOffset;

    LavaPool(float x, float y, float w) : position(x, y), animOffset(0) {
        shape.setSize(sf::Vector2f(w, 30));
        shape.setPosition(position);
        shape.setFillColor(sf::Color(255, 100, 0));
    }

    void update() {
        animOffset += 0.1f;
        sf::Color lavaColor(255, 100 + sin(animOffset) * 50, 0);
        shape.setFillColor(lavaColor);
    }

    sf::FloatRect getBounds() const {
        return shape.getGlobalBounds();
    }
};

class Player {
public:
    sf::RectangleShape body;
    sf::RectangleShape hat;
    sf::CircleShape head;
    sf::RectangleShape eyeLeft;
    sf::RectangleShape eyeRight;
    sf::RectangleShape mustacheLeft;
    sf::RectangleShape mustacheRight;
    sf::RectangleShape legLeft;
    sf::RectangleShape legRight;
    sf::Vector2f position;
    sf::Vector2f velocity;
    float speed;
    float jumpPower;
    bool grounded;
    bool hasHammer;
    float animTimer;

    Player(float x, float y) : position(x, y), velocity(0, 0), speed(4.0f),
        jumpPower(-12.0f), grounded(false), hasHammer(false), animTimer(0) {

        body.setSize(sf::Vector2f(24, 28));
        body.setFillColor(sf::Color::Red);

        head.setRadius(14);
        head.setFillColor(sf::Color(255, 220, 177));

        hat.setSize(sf::Vector2f(28, 8));
        hat.setFillColor(sf::Color::Red);

        eyeLeft.setSize(sf::Vector2f(4, 4));
        eyeLeft.setFillColor(sf::Color::Black);
        eyeRight.setSize(sf::Vector2f(4, 4));
        eyeRight.setFillColor(sf::Color::Black);

        mustacheLeft.setSize(sf::Vector2f(8, 3));
        mustacheLeft.setFillColor(sf::Color(101, 67, 33));
        mustacheRight.setSize(sf::Vector2f(8, 3));
        mustacheRight.setFillColor(sf::Color(101, 67, 33));

        legLeft.setSize(sf::Vector2f(10, 6));
        legLeft.setFillColor(sf::Color(50, 50, 200));
        legRight.setSize(sf::Vector2f(10, 6));
        legRight.setFillColor(sf::Color(50, 50, 200));

        updatePosition();
    }

    void updatePosition() {
        animTimer += 0.15f;
        float legOffset = grounded ? sin(animTimer) * 2 : 0;

        body.setPosition(position.x + 8, position.y + 18);
        head.setPosition(position.x + 4, position.y - 4);
        hat.setPosition(position.x + 2, position.y - 10);
        eyeLeft.setPosition(position.x + 10, position.y + 4);
        eyeRight.setPosition(position.x + 18, position.y + 4);
        mustacheLeft.setPosition(position.x + 6, position.y + 12);
        mustacheRight.setPosition(position.x + 18, position.y + 12);
        legLeft.setPosition(position.x + 8, position.y + 40 + legOffset);
        legRight.setPosition(position.x + 22, position.y + 40 - legOffset);
    }

    sf::FloatRect getBounds() const {
        return sf::FloatRect(position.x, position.y, 32, 46);
    }

    void draw(sf::RenderWindow& window) {
        window.draw(legLeft);
        window.draw(legRight);
        window.draw(body);
        window.draw(head);
        window.draw(hat);
        window.draw(eyeLeft);
        window.draw(eyeRight);
        window.draw(mustacheLeft);
        window.draw(mustacheRight);
    }

    void reset(float x, float y) {
        position = sf::Vector2f(x, y);
        velocity = sf::Vector2f(0, 0);
        grounded = false;
        hasHammer = false;
        updatePosition();
    }
};

class Game {
private:
    sf::RenderWindow window;
    Player player;
    std::vector<Platform> platforms;
    std::vector<Diamond> diamonds;
    std::vector<Enemy> enemies;
    std::vector<FallingRock> fallingRocks;
    std::vector<Icicle> icicles;
    std::vector<LavaPool> lavaPools;
    Hammer* hammer;
    Boulder* boulder;
    sf::RectangleShape exitDoor;

    GameState state;
    int currentLevel;
    int lives;
    int diamondsCollected;
    int score;

    sf::Font font;
    bool fontLoaded;
    sf::Color bgColor;
    float friction;

    const float GRAVITY = 0.5f;
    const int WINDOW_WIDTH = 800;
    const int WINDOW_HEIGHT = 600;

    sf::RectangleShape startButton;
    sf::RectangleShape instructionsButton;
    bool showInstructions;

public:
    Game() : window(sf::VideoMode(800, 600), "Oreo Escape - Cave Adventure"),
        player(100, 300), state(MENU), currentLevel(1), lives(3),
        diamondsCollected(0), score(0), hammer(nullptr), boulder(nullptr),
        showInstructions(false), fontLoaded(false), friction(0.85f) {
        window.setFramerateLimit(60);

        fontLoaded = font.loadFromFile("arial.ttf") ||
            font.loadFromFile("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf") ||
            font.loadFromFile("C:/Windows/Fonts/arial.ttf");

        startButton.setSize(sf::Vector2f(200, 50));
        startButton.setPosition(300, 250);
        startButton.setFillColor(sf::Color(255, 215, 0));

        instructionsButton.setSize(sf::Vector2f(200, 50));
        instructionsButton.setPosition(300, 320);
        instructionsButton.setFillColor(sf::Color(100, 150, 255));
    }

    ~Game() {
        delete hammer;
        delete boulder;
    }

    void loadLevel(int level) {
        platforms.clear();
        diamonds.clear();
        enemies.clear();
        fallingRocks.clear();
        icicles.clear();
        lavaPools.clear();
        delete hammer;
        delete boulder;
        hammer = nullptr;
        boulder = nullptr;

        player.reset(50, 400);
        currentLevel = level;

        if (level == 1) {
            // Level 1: Cave
            bgColor = sf::Color(42, 24, 16);
            friction = 0.85f;

            platforms.push_back(Platform(0, 550, 800, 50, sf::Color(101, 67, 33)));
            platforms.push_back(Platform(200, 450, 150, 20, sf::Color(101, 67, 33)));
            platforms.push_back(Platform(450, 350, 150, 20, sf::Color(101, 67, 33)));
            platforms.push_back(Platform(100, 250, 120, 20, sf::Color(101, 67, 33)));
            platforms.push_back(Platform(650, 250, 100, 20, sf::Color(101, 67, 33)));
            platforms.push_back(Platform(300, 150, 200, 20, sf::Color(101, 67, 33)));

            diamonds.push_back(Diamond(250, 410));
            diamonds.push_back(Diamond(500, 310));
            diamonds.push_back(Diamond(150, 210));
            diamonds.push_back(Diamond(680, 210));
            diamonds.push_back(Diamond(350, 110));

            // Fewer falling rocks and better positioned
            fallingRocks.push_back(FallingRock(400, 80));

            hammer = new Hammer(200, 300);
            boulder = new Boulder(700, 200);

            exitDoor.setSize(sf::Vector2f(40, 60));
            exitDoor.setPosition(720, 170);
            exitDoor.setFillColor(sf::Color(255, 215, 0));

            enemies.push_back(Enemy(220, 430, 1.0f, 200, 330, "fish"));
            enemies.push_back(Enemy(470, 330, 1.2f, 450, 580, "fish"));
        }
        else if (level == 2) {
            // Level 2: Ice Cave
            bgColor = sf::Color(26, 58, 74);
            friction = 0.95f;

            platforms.push_back(Platform(0, 550, 800, 50, sf::Color(168, 216, 234)));
            platforms.push_back(Platform(150, 450, 130, 20, sf::Color(168, 216, 234), true));
            platforms.push_back(Platform(350, 380, 130, 20, sf::Color(168, 216, 234)));
            platforms.push_back(Platform(550, 300, 130, 20, sf::Color(168, 216, 234), true));
            platforms.push_back(Platform(250, 220, 150, 20, sf::Color(168, 216, 234)));
            platforms.push_back(Platform(50, 150, 100, 20, sf::Color(168, 216, 234)));
            platforms.push_back(Platform(600, 150, 150, 20, sf::Color(168, 216, 234)));

            diamonds.push_back(Diamond(190, 410));
            diamonds.push_back(Diamond(390, 340));
            diamonds.push_back(Diamond(590, 260));
            diamonds.push_back(Diamond(300, 180));
            diamonds.push_back(Diamond(80, 110));
            diamonds.push_back(Diamond(650, 110));

            icicles.push_back(Icicle(200, 50));
            icicles.push_back(Icicle(400, 50));
            icicles.push_back(Icicle(600, 50));

            hammer = new Hammer(490, 100);
            boulder = new Boulder(50, 480);

            exitDoor.setSize(sf::Vector2f(40, 60));
            exitDoor.setPosition(60, 440);
            exitDoor.setFillColor(sf::Color(255, 215, 0));

            enemies.push_back(Enemy(170, 430, 0.8f, 150, 260, "jellyfish"));
            enemies.push_back(Enemy(370, 360, 1.0f, 350, 460, "fish"));
            //enemies.push_back(Enemy(570, 280, 1.0f, 550, 660, "jellyfish"));
        }
        else if (level == 3) {
            // Level 3: Lava Cavern
            bgColor = sf::Color(60, 20, 10);
            friction = 0.85f;

            platforms.push_back(Platform(0, 550, 200, 50, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(600, 550, 200, 50, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(100, 450, 120, 20, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(300, 400, 100, 20, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(500, 350, 120, 20, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(200, 280, 150, 20, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(450, 220, 100, 20, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(100, 150, 180, 20, sf::Color(80, 40, 20)));
            platforms.push_back(Platform(600, 180, 150, 20, sf::Color(80, 40, 20)));

            lavaPools.push_back(LavaPool(200, 570, 400));

            diamonds.push_back(Diamond(140, 410));
            diamonds.push_back(Diamond(340, 360));
            diamonds.push_back(Diamond(540, 310));
            diamonds.push_back(Diamond(270, 240));
            diamonds.push_back(Diamond(480, 180));
            diamonds.push_back(Diamond(150, 110));
            diamonds.push_back(Diamond(650, 140));

            hammer = new Hammer(480, 170);
            boulder = new Boulder(650, 480);

            exitDoor.setSize(sf::Vector2f(40, 60));
            exitDoor.setPosition(660, 470);
            exitDoor.setFillColor(sf::Color(255, 215, 0));

            enemies.push_back(Enemy(120, 430, 0.9f, 100, 200, "crab"));
            //enemies.push_back(Enemy(320, 380, 1.1f, 300, 380, "crab"));
            enemies.push_back(Enemy(520, 330, 1.0f, 500, 600, "fish"));
            //enemies.push_back(Enemy(220, 260, 0.8f, 200, 330, "jellyfish"));
        }
        else if (level == 4) {
            // Level 4: Forest Ruins (Vertical)
            bgColor = sf::Color(20, 40, 20);
            friction = 0.85f;

            platforms.push_back(Platform(0, 550, 800, 50, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(300, 480, 200, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(100, 410, 150, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(550, 410, 150, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(350, 340, 100, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(150, 270, 120, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(550, 270, 120, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(350, 200, 100, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(100, 130, 150, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(550, 130, 150, 20, sf::Color(60, 80, 40)));
            platforms.push_back(Platform(300, 60, 200, 20, sf::Color(60, 80, 40)));

            diamonds.push_back(Diamond(370, 440));
            diamonds.push_back(Diamond(150, 370));
            diamonds.push_back(Diamond(590, 370));
            diamonds.push_back(Diamond(380, 300));
            diamonds.push_back(Diamond(190, 230));
            diamonds.push_back(Diamond(590, 230));
            diamonds.push_back(Diamond(380, 160));
            diamonds.push_back(Diamond(150, 90));
            diamonds.push_back(Diamond(370, 20));

            hammer = new Hammer(380, 10);
            boulder = new Boulder(700, 480);

            exitDoor.setSize(sf::Vector2f(40, 60));
            exitDoor.setPosition(710, 470);
            exitDoor.setFillColor(sf::Color(255, 215, 0));

            enemies.push_back(Enemy(120, 390, 0.8f, 100, 230, "fish"));
            enemies.push_back(Enemy(570, 390, 0.9f, 550, 680, "jellyfish"));
            enemies.push_back(Enemy(370, 320, 0.7f, 350, 430, "crab"));
            enemies.push_back(Enemy(170, 250, 0.8f, 150, 250, "fish"));
            enemies.push_back(Enemy(570, 250, 0.9f, 550, 650, "fish"));
            enemies.push_back(Enemy(370, 180, 0.8f, 350, 430, "jellyfish"));
        }
    }

    void handleInput() {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (state == MENU) {
                if (event.type == sf::Event::MouseButtonPressed) {
                    sf::Vector2i mousePos = sf::Mouse::getPosition(window);
                    sf::Vector2f mousePosF(static_cast<float>(mousePos.x), static_cast<float>(mousePos.y));

                    if (startButton.getGlobalBounds().contains(mousePosF)) {
                        lives = 3;
                        score = 0;
                        diamondsCollected = 0;
                        loadLevel(1);
                        state = PLAYING;
                    }
                    else if (instructionsButton.getGlobalBounds().contains(mousePosF)) {
                        showInstructions = !showInstructions;
                    }
                }

                if (event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Enter) {
                    lives = 3;
                    score = 0;
                    diamondsCollected = 0;
                    loadLevel(1);
                    state = PLAYING;
                }
            }
            else if (event.type == sf::Event::KeyPressed) {
                if (event.key.code == sf::Keyboard::Escape) {
                    state = (state == PLAYING) ? PAUSED : (state == PAUSED) ? PLAYING : state;
                }
                if (event.key.code == sf::Keyboard::R && state == PLAYING) {
                    loadLevel(currentLevel);
                }
                if (event.key.code == sf::Keyboard::Enter) {
                    if (state == LEVEL_COMPLETE) {
                        if (currentLevel < 4) {
                            loadLevel(currentLevel + 1);
                            state = PLAYING;
                        }
                        else {
                            state = MENU;
                        }
                    }
                    else if (state == GAME_OVER) {
                        state = MENU;
                    }
                }
            }
        }
    }

    void update() {
        if (state != PLAYING) return;

        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) || sf::Keyboard::isKeyPressed(sf::Keyboard::A)) {
            player.velocity.x = -player.speed;
        }
        else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) || sf::Keyboard::isKeyPressed(sf::Keyboard::D)) {
            player.velocity.x = player.speed;
        }
        else {
            player.velocity.x *= friction;
        }

        if ((sf::Keyboard::isKeyPressed(sf::Keyboard::Space) ||
            sf::Keyboard::isKeyPressed(sf::Keyboard::Up) ||
            sf::Keyboard::isKeyPressed(sf::Keyboard::W)) && player.grounded) {
            player.velocity.y = player.jumpPower;
            player.grounded = false;
        }

        if (sf::Keyboard::isKeyPressed(sf::Keyboard::E) && player.hasHammer && boulder && !boulder->broken) {
            if (player.getBounds().intersects(boulder->getBounds())) {
                boulder->broken = true;
                score += 100;
            }
        }

        player.velocity.y += GRAVITY;
        player.position.x += player.velocity.x;

        for (auto& platform : platforms) {
            if (player.getBounds().intersects(platform.shape.getGlobalBounds())) {
                if (player.velocity.x > 0) {
                    player.position.x = platform.shape.getPosition().x - 32;
                }
                else if (player.velocity.x < 0) {
                    player.position.x = platform.shape.getPosition().x + platform.shape.getSize().x;
                }
                player.velocity.x = 0;
            }
        }

        player.updatePosition();
        player.position.y += player.velocity.y;
        player.updatePosition();

        player.grounded = false;
        for (auto& platform : platforms) {
            sf::FloatRect playerBounds = player.getBounds();
            sf::FloatRect platformBounds = platform.shape.getGlobalBounds();

            if (playerBounds.intersects(platformBounds)) {
                if (player.velocity.y > 0) {
                    float playerBottom = playerBounds.top + playerBounds.height;
                    float platformTop = platformBounds.top;

                    if (playerBottom - player.velocity.y <= platformTop + 5) {
                        player.position.y = platformTop - 46;
                        player.velocity.y = 0;
                        player.grounded = true;
                        player.updatePosition();

                        if (platform.breakable) {
                            platform.breakTimer += 1;
                            if (platform.breakTimer > 120) {
                                platform.shape.setFillColor(sf::Color(168, 216, 234, 150));
                            }
                        }
                    }
                }
                else if (player.velocity.y < 0) {
                    player.position.y = platformBounds.top + platformBounds.height;
                    player.velocity.y = 0;
                    player.updatePosition();
                }
            }
        }

        if (player.position.x < 0) player.position.x = 0;
        if (player.position.x + 32 > WINDOW_WIDTH) player.position.x = WINDOW_WIDTH - 32;

        if (player.position.y > WINDOW_HEIGHT) {
            lives--;
            if (lives <= 0) {
                state = GAME_OVER;
            }
            else {
                loadLevel(currentLevel);
            }
            return;
        }

        for (auto& diamond : diamonds) {
            diamond.update();
            if (!diamond.collected && player.getBounds().intersects(diamond.getBounds())) {
                diamond.collected = true;
                diamondsCollected++;
                score += 50;
            }
        }

        if (hammer && !hammer->collected && player.getBounds().intersects(hammer->getBounds())) {
            hammer->collected = true;
            player.hasHammer = true;
            score += 75;
        }

        for (auto& enemy : enemies) {
            enemy.update();
            if (player.getBounds().intersects(enemy.getBounds())) {
                lives--;
                if (lives <= 0) {
                    state = GAME_OVER;
                }
                else {
                    loadLevel(currentLevel);
                }
                return;
            }
        }

        for (auto& rock : fallingRocks) {
            rock.update(player.getBounds());
            if (rock.active && player.getBounds().intersects(rock.getBounds())) {
                lives--;
                if (lives <= 0) {
                    state = GAME_OVER;
                }
                else {
                    loadLevel(currentLevel);
                }
                return;
            }
        }

        for (auto& icicle : icicles) {
            icicle.update(player.getBounds());
            if (icicle.falling && player.getBounds().intersects(icicle.getBounds())) {
                lives--;
                if (lives <= 0) {
                    state = GAME_OVER;
                }
                else {
                    loadLevel(currentLevel);
                }
                return;
            }
        }

        for (auto& lava : lavaPools) {
            lava.update();
            if (player.getBounds().intersects(lava.getBounds())) {
                lives--;
                if (lives <= 0) {
                    state = GAME_OVER;
                }
                else {
                    loadLevel(currentLevel);
                }
                return;
            }
        }

        if (boulder && boulder->broken && player.getBounds().intersects(exitDoor.getGlobalBounds())) {
            state = LEVEL_COMPLETE;
        }

        player.updatePosition();
    }

    void render() {
        window.clear(state == MENU ? sf::Color(30, 30, 50) : bgColor);

        if (state == MENU) {
            drawMenu();
        }
        else {
            for (auto& lava : lavaPools) {
                window.draw(lava.shape);
            }

            for (auto& platform : platforms) {
                window.draw(platform.shape);
            }

            for (auto& diamond : diamonds) {
                if (!diamond.collected) {
                    window.draw(diamond.shape);
                }
            }

            if (hammer && !hammer->collected) {
                hammer->draw(window);
            }

            if (boulder && !boulder->broken) {
                boulder->draw(window);
            }

            if (boulder && boulder->broken) {
                window.draw(exitDoor);
            }

            for (auto& rock : fallingRocks) {
                if (rock.active || rock.resetTimer > 0) {
                    window.draw(rock.shape);
                }
            }

            for (auto& icicle : icicles) {
                window.draw(icicle.shape);
            }

            for (auto& enemy : enemies) {
                enemy.draw(window);
            }

            player.draw(window);
            drawHUD();

            if (state == PAUSED) drawPauseMenu();
            if (state == GAME_OVER) drawGameOver();
            if (state == LEVEL_COMPLETE) drawLevelComplete();
        }

        window.display();
    }

    void drawMenu() {
        if (fontLoaded) {
            sf::Text title;
            title.setFont(font);
            title.setString("OREO ESCAPE");
            title.setCharacterSize(60);
            title.setFillColor(sf::Color(255, 215, 0));
            title.setPosition(200, 100);
            window.draw(title);

            sf::Text subtitle;
            subtitle.setFont(font);
            subtitle.setString("Cave Adventure Platformer");
            subtitle.setCharacterSize(24);
            subtitle.setFillColor(sf::Color::White);
            subtitle.setPosition(250, 180);
            window.draw(subtitle);
        }

        window.draw(startButton);
        window.draw(instructionsButton);

        if (fontLoaded) {
            sf::Text startText;
            startText.setFont(font);
            startText.setString("START GAME");
            startText.setCharacterSize(24);
            startText.setFillColor(sf::Color::Black);
            startText.setPosition(330, 262);
            window.draw(startText);

            sf::Text instText;
            instText.setFont(font);
            instText.setString("INSTRUCTIONS");
            instText.setCharacterSize(24);
            instText.setFillColor(sf::Color::White);
            instText.setPosition(315, 332);
            window.draw(instText);

            if (showInstructions) {
                sf::RectangleShape panel(sf::Vector2f(460, 280));
                panel.setPosition(170, 290);
                panel.setFillColor(sf::Color(0, 0, 0, 230));
                panel.setOutlineThickness(3);
                panel.setOutlineColor(sf::Color::Yellow);
                window.draw(panel);

                sf::Text controls;
                controls.setFont(font);
                controls.setString("CONTROLS:\n\n"
                    "Arrow Keys or WASD: Move Left/Right\n\n"
                    "Space or W or Up Arrow: Jump\n\n"
                    "E Key: Use Hammer on Boulder\n\n"
                    "ESC: Pause Game\n\n"
                    "R: Restart Current Level\n\n\n"
                    "Collect all diamonds, avoid enemies,\n\n"
                    "break the boulder, and reach the exit!");
                controls.setCharacterSize(16);
                controls.setFillColor(sf::Color::White);
                controls.setLineSpacing(1.2f);
                controls.setPosition(190, 310);
                window.draw(controls);
            }

            sf::Text hint;
            hint.setFont(font);
            hint.setString("Press ENTER or click START to begin");
            hint.setCharacterSize(20);
            hint.setFillColor(sf::Color(200, 200, 200));
            hint.setPosition(230, 520);
            window.draw(hint);
        }
    }

    void drawHUD() {
        sf::RectangleShape hudBg(sf::Vector2f(200, player.hasHammer ? 140 : 120));
        hudBg.setPosition(5, 5);
        hudBg.setFillColor(sf::Color(0, 0, 0, 180));
        window.draw(hudBg);

        if (fontLoaded) {
            sf::Text text;
            text.setFont(font);
            text.setCharacterSize(18);
            text.setFillColor(sf::Color::White);

            std::stringstream ss;
            ss << "Level: " << currentLevel << " of 4\n";
            ss << "Lives: " << lives << "\n";
            ss << "Diamonds: " << diamondsCollected << "\n";
            ss << "Score: " << score;
            if (player.hasHammer) ss << "\nHammer: YES";

            text.setString(ss.str());
            text.setPosition(15, 15);
            window.draw(text);
        }
    }

    void drawPauseMenu() {
        sf::RectangleShape overlay(sf::Vector2f(WINDOW_WIDTH, WINDOW_HEIGHT));
        overlay.setFillColor(sf::Color(0, 0, 0, 200));
        window.draw(overlay);

        if (fontLoaded) {
            sf::Text text;
            text.setFont(font);
            text.setString("PAUSED\n\nESC - Resume\nR - Restart Level");
            text.setCharacterSize(40);
            text.setFillColor(sf::Color::White);
            text.setPosition(280, 220);
            window.draw(text);
        }
    }

    void drawGameOver() {
        sf::RectangleShape overlay(sf::Vector2f(WINDOW_WIDTH, WINDOW_HEIGHT));
        overlay.setFillColor(sf::Color(0, 0, 0, 200));
        window.draw(overlay);

        if (fontLoaded) {
            sf::Text text;
            text.setFont(font);
            std::stringstream ss;
            ss << "GAME OVER\n\n";
            ss << "Final Score: " << score << "\n";
            ss << "Diamonds: " << diamondsCollected << "\n\n";
            ss << "Press ENTER to Menu";
            text.setString(ss.str());
            text.setCharacterSize(36);
            text.setFillColor(sf::Color::Red);
            text.setPosition(220, 180);
            window.draw(text);
        }
    }

    void drawLevelComplete() {
        sf::RectangleShape overlay(sf::Vector2f(WINDOW_WIDTH, WINDOW_HEIGHT));
        overlay.setFillColor(sf::Color(0, 0, 0, 200));
        window.draw(overlay);

        if (fontLoaded) {
            sf::Text text;
            text.setFont(font);
            std::stringstream ss;
            ss << "LEVEL COMPLETE!\n\n";
            ss << "Score: " << score << "\n";
            ss << "Diamonds: " << diamondsCollected << "\n\n";
            if (currentLevel < 4) {
                ss << "Press ENTER for\nNext Level";
            }
            else {
                ss << "YOU WIN!\nAll Levels Complete!\n\n";
                ss << "Press ENTER for Menu";
            }
            text.setString(ss.str());
            text.setCharacterSize(36);
            text.setFillColor(sf::Color::Yellow);
            text.setPosition(220, 150);
            window.draw(text);
        }
    }

    void run() {
        while (window.isOpen()) {
            handleInput();
            update();
            render();
        }
    }
};

int main() {
    Game game;
    game.run();
    return 0;
}